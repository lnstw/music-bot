import os
CONFIG_PATH = "config.txt"
CONFIG_KEYS = [
    "discord_user_name",
    "discord_user_id",
    "spotify_client_id",
    "spotify_client_secret",
    "node_url",
    "node_pw",
    "discord_bot_token"
]
CONFIG_TEMPLATE = """discord_user_name=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑdiscordÂêçÁ®±
discord_user_id=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑdiscord_id
spotify_client_id=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑclient_id
spotify_client_secret=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑclient_secret
node_url=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑlavalinkÁ∂≤ÂùÄ
node_pw=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑlavalinkÂØÜÁ¢º
discord_bot_token=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑdiscord token"""
def check_and_create_config():
    if not os.path.exists(CONFIG_PATH):
        with open(CONFIG_PATH, "w", encoding="utf-8") as f:
            f.write(CONFIG_TEMPLATE)
        print("Â∑≤Ëá™ÂãïÂª∫Á´ã config.txtÔºåË´ãÂ°´ÂÖ•Áõ∏ÈóúË≥áË®äÂæåÈáçÊñ∞ÂïüÂãïÁ®ãÂºè„ÄÇ")
        exit(0)
    config = {}
    with open(CONFIG_PATH, "r", encoding="utf-8") as f:
        for line in f:
            if "=" in line:
                key, value = line.strip().split("=", 1)
                config[key.strip()] = value.strip()
    missing = [k for k in CONFIG_KEYS if k not in config]
    if missing:
        with open(CONFIG_PATH, "a", encoding="utf-8") as f:
            for k in missing:
                f.write(f"{k}=Ë´ãÂ°´ÂÖ•‰Ω†ÁöÑË≥áÊñô\n")
        print(f"config.txt Áº∫Â∞ëÊ¨Ñ‰ΩçÔºåÂ∑≤Ëá™ÂãïË£ú‰∏äÔºö{', '.join(missing)}ÔºåË´ãË£úÈΩäÂæåÈáçÊñ∞ÂïüÂãï„ÄÇ")
        exit(0)
    for k in CONFIG_KEYS:
        if config[k].startswith("Ë´ãÂ°´ÂÖ•"):
            print(f"Ë´ãÂú® config.txt Ë£°Â°´ÂÖ• {k} ÁöÑÊ≠£Á¢∫ÂÄºÂæåÂÜçÂïüÂãï„ÄÇ")
            exit(0)
    return config
config = check_and_create_config()
import discord
import wavelink
import spotipy
from discord.ext import tasks
import datetime
from datetime import timedelta
from spotipy.oauth2 import SpotifyClientCredentials
from discord import app_commands
import aiohttp
from io import BytesIO
import requests
from PIL import Image
import colorsys
import asyncio

class MusicClient(discord.Client):
    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = True
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)
        self.queues = {}
        self.current_songs = {}
        self.last_channels = {}
        self.loop_mode = {}
        self.auto_recommend = {}
        self.force_stop = {}
        self.show_now_song = {}
        self.empty_channel_timers = {}
        self.last_activity = {}
        self.default_volume = 10
        self.status_index = 0
        self.auto_update_tasks: dict[int, asyncio.Task] = {}
        self.spotify = spotipy.Spotify(client_credentials_manager=SpotifyClientCredentials(
            client_id=config["spotify_client_id"],
            client_secret=config["spotify_client_secret"],
        ))
    def generate_status_list(self) -> list[str]:
        guild_count = len(self.guilds)
        user_count = sum(g.member_count or 0 for g in self.guilds)
        playing_count = sum(
            1 for guild in self.guilds
            if guild.voice_client and guild.voice_client.playing
        )
        return [
            "‰ΩøÁî® /help Êü•ÁúãÂπ´Âä©",
            f"Ê≠£Âú®ÂÅ∑Á™∫ {guild_count} ÂÄã‰º∫ÊúçÂô®",
            f"Ê≠£Âú®Áõ£Ë¶ñ {user_count} ÂÄã‰∫∫",
            f"Ê≠£Âú®Êí≠ÊîæÈü≥Ê®ÇÊñº {playing_count} ÂÄã‰º∫ÊúçÂô®"
        ]

    @tasks.loop(seconds=10)
    async def auto_update_status(self):
        try:
            status_list = self.generate_status_list()
            subtitle = status_list[self.status_index]
            self.status_index = (self.status_index + 1) % len(status_list)

            for guild in self.guilds:
                if guild.voice_client and guild.voice_client.playing:
                    song = self.current_songs.get(guild.id)
                    if song:
                        await self.update_presence(current_song=song.title, subtitle=subtitle)
                        return

            await self.update_presence(subtitle=subtitle)
        except Exception as e:
            print(f"Êõ¥Êñ∞ÁãÄÊÖãÊôÇÁôºÁîüÈåØË™§Ôºö{e}")
    async def update_presence(self,current_song: str = None, subtitle: str = None):
        if current_song:
            name = f"{current_song} | {subtitle}"
            activity_type = discord.ActivityType.listening
        else:
            name = f"{subtitle}"
            activity_type = discord.ActivityType.streaming

        activity = discord.Activity(type=activity_type, name=name)
        await self.change_presence(status=discord.Status.dnd, activity=activity)
    async def setup_hook(self):
        try:
            node: wavelink.Node = wavelink.Node(
                uri=config["node_url"],
                password=config["node_pw"],
            )
            await wavelink.Pool.connect(nodes=[node], client=self, cache_capacity=100)
            print('Èü≥Ê®ÇÁØÄÈªûÈÄ£Êé•ÊàêÂäüÔºÅ')
            await self.tree.sync()
            print("ÂëΩ‰ª§Â∑≤ÂêåÊ≠•ÔºÅ")
        except Exception as e:
            print(f'Èü≥Ê®ÇÁØÄÈªûÈÄ£Êé•Â§±ÊïóÔºö{e}')
    async def on_ready(self):
        print(f'Â∑≤ÁôªÂÖ•ÁÇ∫ {self.user}')
        print("Done!")
        self.add_view(RefreshButton())
        self.add_view(opselect_view())
        self.auto_update_status.start() 
        check_inactive_guilds.start()
        guild = discord.utils.get(self.guilds, id=1287276156994981899)
        voice_channel = discord.utils.get(guild.voice_channels, id=1287276156994981903)
        await voice_channel.connect(cls=wavelink.Player)


client = MusicClient()

@tasks.loop(minutes=30)
async def check_inactive_guilds():
    current_time = datetime.datetime.now()
    inactive_timeout = datetime.timedelta(hours=6)
    for guild_id in list(client.last_activity.keys()):
        guild = client.get_guild(guild_id)
        if guild and guild.voice_client and guild.voice_client.playing:
            continue
        last_time = client.last_activity.get(guild_id)
        if last_time and (current_time - last_time) > inactive_timeout:
            if guild_id in client.queues:
                client.queues[guild_id].clear()
            if guild_id in client.current_songs:
                del client.current_songs[guild_id]
            if guild_id in client.loop_mode:
                client.loop_mode[guild_id] = False
            if guild_id in client.auto_recommend:
                client.auto_recommend[guild_id] = False
            if guild_id in client.force_stop:
                client.force_stop[guild_id] = False
            if guild_id in client.show_now_song:
                client.show_now_song[guild_id] = False
            if guild_id in client.empty_channel_timers:
                del client.empty_channel_timers[guild_id]
            del client.last_activity[guild_id]
            print(f"Â∑≤ÈáçÁΩÆÈñíÁΩÆ‰º∫ÊúçÂô® (ID: {guild_id}) ÁöÑÁãÄÊÖã")

EMBED_COLORS = {
    'success': discord.Color.green(),
    'error': discord.Color.red(),
    'info': discord.Color.blue(),
    'warning': discord.Color.yellow(),
    'spotify': discord.Color.from_rgb(30, 215, 96),
    'youtube': discord.Color.from_rgb(255, 0, 0)
}

class Song:
    def __init__(self, url: str, title: str, duration: int, thumbnail: str, requester: discord.Member, platform: str):
        self.url = url
        self.title = title
        self.duration = duration
        self.thumbnail = thumbnail
        self.requester = requester
        self.platform = platform.lower()

class opselect_view(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(opselect())

class LavalinkStatusView(discord.ui.View):
    def __init__(self, embeds: list[discord.Embed]):
        super().__init__(timeout=60)
        self.embeds = embeds
        self.current_page = 0
        self.update_buttons()

    def update_buttons(self):
        self.previous.disabled = self.current_page == 0
        self.next.disabled = self.current_page >= len(self.embeds) - 1

    @discord.ui.button(label="‚¨ÖÔ∏è ‰∏ä‰∏ÄÈ†Å", style=discord.ButtonStyle.secondary)
    async def previous(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.current_page > 0:
            self.current_page -= 1
            self.update_buttons()
            await interaction.response.edit_message(embed=self.format_embed(), view=self)

    @discord.ui.button(label="‚û°Ô∏è ‰∏ã‰∏ÄÈ†Å", style=discord.ButtonStyle.secondary)
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.current_page < len(self.embeds) - 1:
            self.current_page += 1
            self.update_buttons()
            await interaction.response.edit_message(embed=self.format_embed(), view=self)

    def format_embed(self):
        embed = self.embeds[self.current_page]
        embed.set_footer(text=f"Á¨¨ {self.current_page + 1} / {len(self.embeds)} È†ÅÔΩúÁ∏ΩË®à {len(self.embeds)} ÂÄã‰º∫ÊúçÂô®Ê≠£Âú®Êí≠Êîæ")
        return embed

class opselect(discord.ui.Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="Lavalink Êí≠ÊîæÁãÄÊÖã", value="Lavalink Êí≠ÊîæÁãÄÊÖã"),
            discord.SelectOption(label="Êõ¥Êñ∞Ê©üÂô®‰∫∫ÁãÄÊÖã", value="Êõ¥Êñ∞Ê©üÂô®‰∫∫ÁãÄÊÖã")
        ]
        super().__init__(placeholder="ÈÅ∏ÊìáÂäüËÉΩ", min_values=1, max_values=1, options=options, custom_id="persistent_view:op_select")
    async def callback(self, interaction: discord.Interaction):
        op_select = self.values[0]
        if op_select == "Lavalink Êí≠ÊîæÁãÄÊÖã":
            embeds = []
            for guild in client.guilds:
                if guild.voice_client and guild.voice_client.playing:
                    current_song = client.current_songs.get(guild.id)
                    queue_length = len(client.queues[guild.id]) if guild.id in client.queues else 0
                    status_parts = []
                    if client.loop_mode.get(guild.id, False):
                        status_parts.append("üîÑÂæ™Áí∞")
                    if client.auto_recommend.get(guild.id, False):
                        status_parts.append("‚ú®Êé®Ëñ¶")
                    voice_channel = guild.voice_client.channel
                    member_count = len([m for m in voice_channel.members if not m.bot])

                    embed = discord.Embed(
                        title="üéµ Lavalink Êí≠ÊîæÁãÄÊÖã",
                        description=f"üì° {guild.name}",
                        color=EMBED_COLORS['info']
                    )
                    embed.add_field(name="üéµ Êí≠Êîæ‰∏≠", value=current_song.title if current_song else "Êú™Áü•", inline=False)
                    embed.add_field(name="üë• È†ªÈÅì", value=f"{voice_channel.name} ({member_count}‰∫∫Âú®Á∑ö)", inline=True)
                    embed.add_field(name="üìã ‰ΩáÂàó", value=f"{queue_length} È¶ñ", inline=True)
                    embed.add_field(name="‚öôÔ∏è ÁãÄÊÖã", value=' | '.join(status_parts) if status_parts else '‚û°Ô∏è ‰∏ÄËà¨Êí≠Êîæ', inline=False)
                    embeds.append(embed)

            if not embeds:
                embed = discord.Embed(
                    title="üéµ Lavalink Êí≠ÊîæÁãÄÊÖã",
                    description="ÁõÆÂâçÊ≤íÊúâ‰º∫ÊúçÂô®Ê≠£Âú®Êí≠ÊîæÈü≥Ê®Ç",
                    color=EMBED_COLORS['info']
                )
                await interaction.response.send_message(embed=embed, ephemeral=True)
            else:
                view = LavalinkStatusView(embeds)
                await interaction.response.send_message(embed=view.format_embed(), view=view, ephemeral=True)
        if op_select == "Êõ¥Êñ∞Ê©üÂô®‰∫∫ÁãÄÊÖã":
            for guild in client.guilds:
                if guild.voice_client and guild.voice_client.playing:
                    current_song = client.current_songs.get(guild.id)
                    if current_song:
                        await client.update_presence(current_song.title)
                        await interaction.response.send_message("‚úÖ Â∑≤Êõ¥Êñ∞Èü≥Ê®ÇÊ©üÂô®‰∫∫ÁãÄÊÖãÈ°ØÁ§∫", ephemeral=True)
                        return
            await client.update_presence()
            await interaction.response.send_message("‚úÖ Â∑≤Êõ¥Êñ∞Èü≥Ê®ÇÊ©üÂô®‰∫∫ÁãÄÊÖãÈ°ØÁ§∫", ephemeral=True)

class RefreshButton(discord.ui.View):
    def __init__(self, image_url: str = None):
        super().__init__(timeout=None)
        if image_url:
            self.add_item(discord.ui.Button(label="ÈªûÊàëË∑≥ËΩâ", url=image_url, style=discord.ButtonStyle.link))

    @discord.ui.button(label="ÈáçÊñ∞ÂèñÂæó", style=discord.ButtonStyle.primary, custom_id="refresh_button")
    async def refresh(self, interaction: discord.Interaction, button: discord.ui.Button):
        ref_embed = discord.Embed(title="<a:loading:1429472831103832195> ÈáçÊñ∞ÂèñÂæó‰∏≠...", color=discord.Color.yellow())
        await interaction.response.edit_message(embed=ref_embed, view=None)

        start_time = datetime.datetime.now()
        async with aiohttp.ClientSession() as session:
            async with session.get("https://api.redbean0721.com/api/img?type=json") as api_response:
                end_time = datetime.datetime.now()
                if api_response.status != 200:
                    await interaction.edit_original_response(content="ÁÑ°Ê≥ïÁç≤ÂèñÂúñÁâáÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ")
                    return
                data = await api_response.json()
                image_url = data.get("url")
                tag = data.get("tag")
                color_task = asyncio.create_task(get_dominant_color(image_url))
                image_task = asyncio.create_task(session.get(image_url))
                image_response = await image_task
                image_bytes = await image_response.read()
                embed_color = await color_task
                elapsed = (end_time - start_time).total_seconds()
                embed = discord.Embed(
                    title="Èö®Ê©üÂúñ",
                    color=embed_color,
                    description=f"ÊèêÁ§∫Ë©û: {tag}",
                )
                file = discord.File(BytesIO(image_bytes), filename="image.jpg")
                embed.set_image(url="attachment://image.jpg")
                embed.set_footer(text=f"ÂõûÊáâÊôÇÈñì: {elapsed:.2f}s")
                embed.timestamp = datetime.datetime.now()
                view = RefreshButton(image_url=image_url)
                await interaction.edit_original_response(embed=embed, view=view, attachments=[file])

async def get_dominant_color(url):
    def sync_get_color():
        try:
            response = requests.get(url, timeout=10)
            img = Image.open(BytesIO(response.content))
            img = img.resize((50, 50)).convert('RGB')
            pixels = list(img.getdata())
            r_avg = sum(p[0] for p in pixels) // len(pixels)
            g_avg = sum(p[1] for p in pixels) // len(pixels)
            b_avg = sum(p[2] for p in pixels) // len(pixels)
            h, s, v = colorsys.rgb_to_hsv(r_avg/255, g_avg/255, b_avg/255)
            v = max(min(v * 1.5, 1.0), 0.5)
            r, g, b = colorsys.hsv_to_rgb(h, s, v)
            return discord.Color.from_rgb(int(r*255), int(g*255), int(b*255))
        except:
            return discord.Color.green()

    return await asyncio.to_thread(sync_get_color)